
一、线程池

1、线程

  线程的三种实现方式：Thread、Runnable、Callable
  
  线程的生命状态：
    NEW：新建
    RUNNABLE:运行
    BLOCKED:阻塞
    WAITING:等待
    TIMED_WAITING:超时等待
    TERMINATED:终结
    
   线程间的状态切换：https://www.processon.com/diagraming/5e7bfce6e4b027d999cd22cf
  
方式一：继承Thread

  class TestThread extends Thread{
  
    @Override
    
    public void run() {
    
        System.out.println("我是继承Thread");
        
    }
}

new TestThread().start();

方式二、实现Runnable

  class TestRunnable implements Runnable{
  
    @Override
    
    public void run() {
    
        System.out.println("我是实现自Runnable");
        
    }
}
new Thread(new TestRunnable()).start();

方式三、实现Callable

  class TestCallable implements Callable<String>{
  
    private String acceptStr;
  
    public TestCallable(String acceptStr){
  
        this.acceptStr = acceptStr;
  
    }
  
    @Override
  
    public String call() throws Exception {
  
        Thread.sleep(1000);
  
        return this.acceptStr + "append some chars and return it!";
  
    }
}
  
FutureTask<String> futureTask = new FutureTask<>(new TestCallable("my callable test!"));
  
new Thread(futureTask).start();
  
System.out.println(futureTask.get());
 
2、线程池
  
  线程模型分为两类：用户级线程（ULT）和内核及线程（KLT）
  
  用户级线程（user level thread）: 系统内核对ULT无感知，线程的创建和调度都由用户级APP进程管理，即APP自行管理的线程就是用户线程
  
  内核级线程（kernel level thread）: 线程的创建，调度和切换上下文等，都由操作系统级内核管理
  
  在执行的区别上，ULT和KLT最大的区别就是：ULT线程的调度不需要内核直接参与，控制简单，创建和销毁线程、线程切换代价等线程管理比内核线程少的多。但是其资源调度按照进程进行，不能利用系统多核处理，多个处理器下，同一个进程中的线程只能在同一个处理下分时复用；KLT由内核进行调度，当有多个处理器时，一个进程的多个线程可以同时执行，但是KLT线程的创建和切换等开销很大。在ULT上线程是由用户空间自行维护，内核空间不管，用户空间和内核空间只是进程间的对应关系。在KLT上用户空间的线程和内核空间的线程是一一对应的。
  java线程是依赖于系统内核，通过JVM调用系统库（操作系统提供的API）创建内核线程。Java的Thread和内核线程呈1：1映射关系。由于创建和销毁线程消耗系统资源，所以我们需要线程池进行线程池化管理的原因。
  https://user-images.githubusercontent.com/38527234/126577369-199dfe16-2c5c-488c-951a-48601e945731.png
  https://user-images.githubusercontent.com/38527234/126577401-6193da1b-2a12-4eb6-8844-51bc83a12831.png

  
  
  
  
  
  
  
  
  
  
  
  
  
